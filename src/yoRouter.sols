// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import { IyoVault } from "src/interfaces/IyoVault.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Address } from "@openzeppelin/contracts/utils/Address.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { IERC4626 } from "@openzeppelin/contracts/token/ERC20/extensions/ERC4626.sol";

interface Vault is IyoVault, IERC4626 { }

interface IWETH is IERC20 {
    function deposit() external payable;
    function withdraw(uint256) external;
}

contract yoEthRouter {
    using SafeERC20 for IERC20;
    using Address for address payable;

    mapping(address user => uint256 amount) public userShares;

    IWETH public immutable weth;
    Vault public immutable vault;

    constructor(address _weth, address _vault) {
        weth = IWETH(_weth);
        vault = Vault(_vault);
    }

    /// @notice Deposits ETH into the vault after converting to WETH
    /// @param assets The amount of ETH to deposit, must match the msg.value sent
    /// @param receiver The address to receive the vault shares
    /// @return shares The number of shares minted
    function deposit(uint256 assets, address receiver) external payable returns (uint256 shares) {
        require(assets == msg.value, "Assets mismatch");
        require(msg.value > 0, "No ETH sent");

        // Convert ETH to WETH
        weth.deposit{ value: msg.value }();

        // Approve WETH to the vault
        weth.approve(address(vault), msg.value);

        // Deposit WETH into the ERC-4626 vault
        shares = vault.deposit(msg.value, receiver);
    }

    /// @notice Withdraws ETH from the vault by redeeming shares

    function requestRedeem(uint256 shares, address controller, address owner) external returns (uint256 assets) {
        require(owner == msg.sender);

        IERC20(vault).safeTransferFrom(owner, address(this), shares);
        IERC20(vault).approve(address(vault), shares);

        assets = vault.requestRedeem(shares, address(this), address(this));

        // in case of instant redeem
        if (assets > 0) {
            weth.withdraw(assets);
            payable(owner).sendValue(assets);
        }
        // in case of pending redeem, we must assume that the operator will fulfill the request with all the shares
        else {
            userShares[controller] += shares;
        }
    }

    function withdraw(uint256 assets, address receiver, address controller) external {
        uint256 shares = vault.withdraw(assets, address(this), address(this));
        require(userShares[controller] >= shares, "Insufficient shares");
        userShares[controller] -= shares;
        weth.withdraw(assets);
        payable(receiver).sendValue(assets);
    }
}
